Programming is Writing a sequence of instructions that tell computers how to perform a task written in a programming language.
Computer Science is the study of algorithms and the use of computers to solve problems and tasks.
Binary is a number system consisting of 0 and 1 (Base 2).
ASCII is the American Standard Code for Information Interchange. This is a table that assigns numbers to represent characters.
Decimal is base 10. Hexadecimal is base 16. Octal is base 8. Binary is base 2.
--------
Literal := specific data item:
	Numeric literals include:
		Integers (5) : No size restrictions on ints in python.
		Floating point (3.14)
		Imaginary/Complex (3j)
	String literals --> "Hi"
		Strings are a sequence of characters.
		Three methods of writing:
			'Text'
			"Text"
			"""Text""" <-- Multiline string.
		Escape Sequences are a set of character that enable insertion of special characters into a string
			\newline := newline
			\\		 := \
			\'		 := '
			\"		 := "
			\a		 := ASCII Bell
			\b		 := ASCII Backspace
			\f		 := ASCII Formfeed
			\n		 := Ascii Linefeed (newline)
			\N{name} := Character named name in Unicode
			\r		 := ASCII Carriage Return
			\t		 := ASCII Horizontal tab
		Joined two existing strings together to make a new string, using +.
			Called Concatenation. + <-- Overloaded.
	Boolean literals:
		True
		False
Expressions := A combination of values, variables, operators, and function calls that are interpreted (evaluated/resolved) according to the rules of precedence and assocation for a language.
	Returns a value. It is reduced from expression to value.

Operators := Operations so common that it is not necessary to write a function for.
	Obeys precedence heirarchy.
		Infix (2 + 3) [Between two arguments]
		Prefix (-5)   [Preceding the argument]
		Mixfix (expr) [Wrapped around its argument]
Rules of Precendece := What is evaluated first in python.
	Most operators are evaluated left to right in PEMDAS order.
	Following that is bitwise operations, comparators, and lambda.
	From greatest to least:
		Parens
		Expons
		Mult
		Division
		Add
		Subtract
		Bitshift (>>, <<)
		Bit AND	(&)
		Bit XOR (^)
		Bit OR  (|)
		Comparison (in, not in, is, is not, <, <=, >, >=, <>, !=, ==)
		Bool NOT (not)
		Bool AND (and)
		Bool OR  (or)
		lambda   (lambda)
Conversion Functions change variable types:
	Example: int(), float(), str(), bool(), eval() <-- Evaluates expression
More conversion:
	chr(i) - Returns a string of one character whose ASCII code is int i.
	ord(c) - if str len(c) == 1, return int representing Unicode char or byte value if c is an 8-bit string.
	bin() - Convert int to binary string.
	oct() - ^ but octal
	hex() - ^ but hexadecimal
type() :== IDs data type.
Python Docs:
	Lang Ref describes syntax and core semantics.
	Lib Ref describes standard lib in python, with optional commonly used components. Also describes "built-in" functions.

BNF := Backus Naur Form
	Formal notation to describe language.
	Each rule begins with a name and ::= (definition)
	| ::= alternatives
	* ::= zero or more repetitions of preceding item
	+ ::= one or more repetitions of preceding item
	[] ::= A phrase enclosed in square brackets, means zero or one occurances.. <-- Optional.
	
	* and + bind tightly, parens for grouping. Strings are in quotes. Whitespace is meaningful to tokens.
--------
Variables is a named storage space for a value.
	Assignment like this:
		name = expression
		further assignments update variable values.
	Complicated assignment/Multiple Assignment:
		x=y=z=1 (x, y, z all equal 1)
		x, y, z = 1, 2, "string" (x=1, y=2, z="string")
	Swapping:
		x=5, y=10
		x,y = y,x (x=10, y=5)
Identifiers := An allowed name in a computer language.
	Used as names for variables (rep. data), functions (rep. process), modules (rep. collection of variables, functions)
	3 Categories:
		Keywords - Reserved words that form a construct of the language
			Keywords cannot be used as normal identifiers. Must be spelled exactly like this:
				False, None, True, and, as, assert, break, class, continue, def, del, elif, else, except, finally, is, lambda, nonlocal, not, or, pass, raise, return, try, while, with yield
		Built-ins - Special words defined and/or used by interp.
		User defined - Words created by user to represent variables, funcs, constants.
			Naming rules: Cannot contain spaces. Begin with letters or _
			Cannot be reserved word/built-in . Case-sensitive.
			Conventions for id. Choose descriptive names, implenting self-documenting code. Stay consistant.
--------
Statements := Command to computer to do something. Contains other statements or expressions.
	Two types:
		Simple: Assignment statement, Return statement
		Compound: Logical context, control structures
		Assignment is same as variable.
			name = expression/variables <-- This is a statement.
		Shortcut Assignments:
			+= (add right to left)
			-= (subtract right from left)
			*= (multiply right to left)
			/= (divide left by right)
			//= (integer divide left by right)
			%= (modulo left by right)
			**= (left to the right power) 
	Multiline Statements: "blah blah" + \
							"blah" + \ <-- Line continuation ops.
Expressions := Representation that can be simplified down to a value. The expression itself gives no indication of what to do with the value.
	Once computed, resolves to a value and returns it. It is a serious of simplification until it gets there.
Rules of Assocation:= The rule the interp uses to make assocations with constructs in syntax.
	Parenthesis assoc with functions.
	Ident assoc with code block.
	Colon assoc with context def.
--------
input() := Gets user input.
eval() := Accept string, assumes python expression in it, simplifies it, then gives result.
# <-- Comment operand.
"""this make a docstring"""
Make your code readable.
--------
Two interp modes:
	Interactive:
		Open python in terminal. Allows testing of precise statements, gives immediate feedback, helps in learning basic operations of syntax, functions.
		Not intended for exec user modules and functions.
	Module/Source file exec:
		run python3 <filename>.py
		or run python3 -i <filename>.py
			will run the filename and escape into interactive mode after quitting the program.
--------
Types of Errors:
	Syntax Errors: Incorrect syntax due to spelling, missing operators. Easiest to fix.
	Runtime Error: Compiled/interpreted, but crashes when encountering certain data.
	Logic Errors: Executes, but provides incorrect, inconsistent output.
--------
Algorithm: A set of ordered steps for solving a problem, such a mathematical formula or the instructions in a program.
Pseudocode: A non-programming-language-specific implementation of an algorithm.
Flow Charts are a visual way to represent an algorithm.
	Different shapes and arrows have meaning, obeying the meanings causes traveling around the chart, accomplishing the task.
--------
Boolean Operators:
	and - if both are True, then return True. Else false.
		written like this: True and False , or a=True, b=False; a and b
		in boolean expressions, and has greater precedence. Causes x and y or z to be grouped (x and y) or z
	or  - if at least one is True, then return True. Else false.
		written like this: True or False, or a=True, b = False; a or b
	not - if True, then False. Elif False, then True.
		written like this: not True, not False, or a=True, b=False; not a, not b
	Truth Tables:
	p|q|p and q|p or q|not p|not q|		x|y|z|x and y or z| := (x and y) or z
	-------------------------------		-------------------
	T|T|   T   |  T   |  F  |  F  |		T|T|T|	 T	  T	  |T
	T|F|   F   |  T   |  F  |  T  |		T|T|F|	 T    T   |T
	F|T|   F   |  T   |  T	|  F  |		T|F|T|	 F    T	  |T
	F|F|   F   |  F   |  T  |  T  |		T|F|F|	 F    F	  |F
										F|T|T|	 F    T   |T
										F|T|F|	 F    F   |F
										F|F|T|	 F    T   |T
										F|F|F|	 F    F	  |F
Comparisons:
	Supported by all objects. (Simply to boolean values) and are all of the same precendence (higher than boolean operators.)
	Comparisons can be chained:
		x<y<=z == x<y and y<=z  ( Except than y is evaluated once in one of the expressions. z is not evaluated at all if x<y is false.)
	Operation Chart:
	< 	   | Strictly less than
	<=	   | Less than or equal to
	> 	   | Strictly greater than
	>=	   | Greater than or equal to
	==	   | Equal to
	!= 	   | Not equal to
	is	   | Object identity
	is not | Not that object
		the is keyword checks if two names point to the same memory location
Boolean Conditions are created by comparing values
Comparison Operators are usd to compare values, resulting in a boolean.
	x = 5 != x ==5. x =5 is an assignment. x==5 is an expression.

Truth Value Testing:
	Any object can be tested for truth value, for use in an if or while condition or as an operand of the boolean operations below. The follow are considered False:
		None, False, zero in any numeric type (0, 0.0, 0j), any empty sequence ('', (), []), any empty mapping ({}), instances of classes with __boolean__() or __len__() method when it returns 0 or False.
	All other values are considered True, so objects of many types are always considered True.
	Operations and built-in functions that have boolean results always return 0 or False for false, and 1 or True for true, unless otherwise stated.
		Exception: operands or or and always return one of their operands.
--------
Program Operations:
	Three basic modes for procedural program operations:
		Sequential: The normal program flow, each statement executed one after the other, in sequence.
		Branching:	Deviation from sequential, statements are conditionally executed according to a logical decision.
			A program taking one path/branch of code instead of the other due to boolean condition.
			if/elif/else structure:
				if <cond>:
					<expr>
				elif <cond2>:
					<expr2>
				else:
					<expr3>
			Think of else blocks as default behavior. If the else block is missing, the default is simply not to do anything.
		Repetition: Deviation from sequential, statements are conditionally repeated according to a logical decision.
			A program that repeatedly runs a block of code, some number of times, based on a boolean condition.
				Classified as definite (for) or indefinite (most while) loop.
					Definite: When the number of loops is static (or can be known or calculated from something)
					Indefinite: When the number of loops is dynamic (or can only be determined at runtime by sentinel value or direct user input)
				while structure:
				while <cond>:
					<code>
				for structure:
				for var in sequence:
					<code>
				or
				for var in range(<args>):
					<code>
				Sequence: an ordered series of elements.
					string - sequence of characters
					list   - sequence of values
				range() := creates a sequence of numbers
					has three arguments, start, stop, step. Direction of increment is determined by start < stop and step.
					You can omit variables. range(1, 10, 1) produces [1,2,3,4,5,6,7,8,9]
					One variable omitted, default step.
					Two variables omitted, default step and start.
					Three variables omitted, you have an empty range.
				list()  := prints a series of values.
				
			Break and Continue:
				continue is a keyword that can only occur within a loop (not in a class or a finally), continues with the next cycle of the nearest enclosing loop
					when passed inside of a try statement with a finally clause, finally is executed and then the next cycle continues.
				break can only occur within a loop (but not a function or class definition in it). It terminates the nearest loop, skipping the else for that loop.
					If a for loop is broken, loop control target/variable keeps it's current value.
			Easy to use and abuse. Try not to use unless for clarity.
--------
Sequences is an ordered group of values, accessable via indexing.
	Operations:
		x in s | True if an item of s is equal to x, else False.
		x not in s | False if an item of s is equal to x, else True.
		s + t | Concatenation of s and t.
		s * n, n * s | n shallow copies of s concatenated
		s[i] | ith item of s, origin 0.
		s[i:j] | slice of s from i to j.
		s[i:j:k] | slice of s from i to j with step k
		len(s) | length of s
		min(s) | smallest item of s
		max(s) | largest item of s
			only use min/max when sequence only has one type of elements
	Mutable sequence Operations:
		s[i] = x | item i of s is replaced by x
		s[i:j] = t | slice of s from i to j is replaced by the contents of the iterable t
		del s[i:j] | same as s[i:j] = []
		s[i:j:k] = t | the element of s[i:j:k] are replaced by those of t
		del s[i:j:k] | removes the elements of s[i:j:k] from the list
		s.append(x) | same as s[len(s):len(s)] = [x]
		s.extend | same as s[len(s):len(s)] = x
		s.count(x) | return number of is for which s[i] == x
		s.index(x[, i[, j]]) | return smallest k such that s[k] == x and i <= k < j
		s.insert(i,x) | same as s[i:i] = [x]
		s.pop([i]) | same as x = s[i]; del s[i]; return x
		s.remove(x) | same as del s[s.index(x)]
		s.reverse() | reservses the items of s in place
		s.sort([cmp[, key[, reverse]]]) | sort the items of s in place
	Strings is an ordered sequence that is immutable and are enclosed in quotes.
		Ex: "Hello"
	Lists are an ordered sequence of any python values that is mutable and are comma-separated values in square brackets.
		Ex: [h,"e","ll", o]
			[3] != 3 | [[3]] != [3]
	Tuples is an ordered sequence of any Python values, immutable, and are in comma-separated values (usually in parentheses, but not required.)
		Ex: (h,"e", "ll", o) or h,"e", "ll", o
			One-tuples -need- the comma. (3) != (3,)
Indexing:
 0  1  2  3  4
|i||n||d||e||x|
-5 -4 -3 -2 -1
	To identify one value within a sequence we can use the numbers zero and up to access it:
		msg = "hello there"
		print(msg[0]) # prints h
		print(msg[6]) # prints t
		print(msg[11]) # error. out of bounds
		nums = [15, 10, 32, 16]
		print(nums[-1]) # prints 16
		print(nums[-4]) # prints 15
		print(nums[-5]) # error- out of bounds.
Slicing:
	We can grab a sub-sequence by selecting a portion of the values from an existing list.
		msg = "hello there"
		msg2 = msg[3:9] # "lo the" . given start, stop.
		msg3 = msg[0:10:3] # "hltr". given start, stop, step.
		msg4 = msg[8:2:-1] # "eht ol". Given all three, but goes in reverse (start-> stop direction reversed.)
		msg4 = msg[0:10:-1] # Empty string. Nothing was grabbed.
		msg4 = msg[1:1000] # "ello there" Grabs what indexes it can.
		msg5 = msg[6:] # "there" grabs from index 6 on.
		msg6 = msg[:5] # "hello" grabs up to index 5.
		msg7 = msg[:] # Grabs it all. "hello there"
	When there are sequences of sequences, one can index into sub-sequence.
		lis = [[1,2,3],[4,5,6],["abc","def","ghi"]]
		letter = lis[2][0][1] #grabs "b"
		num = lis[1:3][0][:-4:-1][2] # grabs 4. (One can apply slice index into subsequences)

Complex Data Types:
	Some sequences are multi-dimensional.
		xs = [1,2,3] ; ys = [4,5,6]
		listoflists=[xs,ys]
	Updating lists:
		xs = [5,10,15,20]
		xs[2] = 3 # xs == [5,10,3,20]
		xs[1:3] = [6,7,8,9] # xs == [5,6,7,8,9,20]
		xs[1:3] = 5 # Error. Length of old and new slices don't have to match, but a list must be provided.

Immutable Data Types:
	Cannot be modified once delcared, but can be re-declared with new values.

Data References:
	mixlist ex:
		lis = [1,2,3]
		tup = (1,2,3)
		string = "123"
		mixlist = [string, tup, lis]
		mixlist == ['123', (1,2,3), [1,2,3]]
		lis = [4,5,6]
		tup = (4,5,6)
		string = "456"
		mixlist == ['123', (1,2,3), [1,2,3]]
		# Mixlist copied the old values. However, new variable values does not affect mixlist.
	xs,ys, lists ex:
		xs = [1,2,3]
		ys = [4,5,6]
		lists = [xs, ys]
		lists == [[1,2,3], [4,5,6]]
		xs[1] = 20 # Changes element of original list
		lists == [[1,20,3], [4,5,6]] # Change reflected.
		xs = [7,8,9] # Reassign list
		lists == [[1,20,3], [4,5,6]] # No impact.
		lists[0][1] = 85 # Change element in embedded list, directly.
		lists == [[1,85,3], [4,5,6]] # Change reflected.
			Why does it happen?
			Complex values can have multiple 'names' (such as xs and lists[0]), and python is careful to preserve these different names for the same value. Changing one means both update.
				Many parts of your program can have their own references to a value and modify/read it as needed. Functions can receive mutable values for its parameters. Function can update it and changes are visible from outside the function call without even returning a value.
			When we reassign one of those, Python no longer keeps pointing to the same value as the other names.
			Reassigning (xs=[new, values]) creates a new list and Python uses that for xs. Reassign, we point the variable at entirely new values. Different memory location will be used for that new value.
			Updating (xs[0] =newval) reuses the same list value, so the different names are still related. Update, we modify part of the value stored there. It's at the same place
	id() --> Returns the identity of an object as an int which is guaranteed to be unique and constant for this object during its lifetime.

Shallow Copies:
	Another effect driven by data references - "copies" made are simply multiple references to the same objects, or "shallow copies."
	ex:
		xs = [1,2,3]
		biglist = xs*3 #Because biglist looks up the value of xs and 3's it, copying the contents of xs without making aliases. There are no complex values (e.g. lists) inside biglist.
		xs[1] = 99 # biglist = [xs]*3 would create the list of lists so each sub-list is a complex value that can exhibit reference updating (of course, the meaning is slightly different too, originally biglist was one-dimensional, now it would be two-dimensional.)

Tuple: A complex data type, a sequence, immutable.
List : A complex data type, a sequence, mutable
	Well, mutable tuples are called... lists.
Tuple vs. List:
	List --> Generally homogenous, containing the same data types and processing involves elements with a common nature.
	Tuple --> Generally heterogeneous: contain different data types and processing generally involves accessing various aspects of a collective entity.
--------
Sequences and Loops:
	Loops are most useful with sequences. Each iteration of the loop can inspect/use/modify one value in the sequence.
		Ex:
			xs = [5,2,14,63]
			for x in xs:
				print(x)
	"Value" for-loop:
		For loops assign each value of the supplied sequence to the loop variable.
			Ex:
				words = ["you", "are", "great"]
				for val in words:
					print(val)
	"Index" For-loop:
		We can create the indexes we'd like to use and supply those to a for-loop instead of the actual sequence we'll be using.
			for i in [0,1,2]:
				print(words[i])
			for i in range(len(words)):
				print(words[i])
Value vs Index:
	Value: Value assigned to supplied sequence of loop variable.
	Index: Indexes for sequence provided to be used.

Indexing in other orders:
	By constructing a different call to range(), we can index through our sequence in more sophisticated ways than just "in-order, all elements":
		val= [11,12,13,14,15,16,17,18]
		for i in range(0, len(vals),2):
			print(vals[i])
		for i in range(len(vals)-1, -1, -1):
			print(vals[i]) #Watch out! using range(), you must get the indexes exactly right. Only slicing gracefully ingores out-of-bounds issues.
	
	for-loop with tuples
		We can dissect a tuple with for-loop variables.
		This is called "pattern-matching"
		tups = [('a', 1), ('b',2), ('c',3)]
		for (c,n) in tups:
			print(c*n)
	# a 
	# bb
	# ccc
--------
Strings:
	A complex data type (Has sub-components/elements)
	A sequence (sequential elements, has specific ordering.)
	Is immutable.
	String methods:
		Method: an action or process (defined relative to a particular object) to be performed
			Example of string methods:
				usage: stringExpr.methodName(args)
				capitalize() --> caps first char, lowers the rest
				endswith(svar[,start[,stop]]) --> returns Boolean if string ends with svar
				isalpha, isdigit, isdecimal, isnumeric, isidentifier, islower --> boolean answers
				join(iterable) --> like extend for strings. Separator is the initial string
				replace(old,new[,count])
				split(sep) --> list of strings split at sep substrings
				upper(), lower() --> converts letters to upper/lower case
		Dot Operator: a dot(period) that is used to access an associated variable or call an associated function
		Examples:
			object_name.method_name
			strVar = "Test"
			strVar.upper() #TEST
	Operations vs Methods:
		Sequences Operations
			May be built-in functions
			Operate on various data types
			Example:
				len # len(strVar), len([1,2,3])
		Methods:
			Operate on a single data type
			String object methods (e.g., capitalize)
			strVar.capitalize()
	min(string) is ''
	max(string) returns the character with the highest ascii number.
		ord(char) --> Converts single character to corresponding ASCII int val
		chr(int)  --> converts integer value to  corresponding char symbol
			Ascii "American Standard Code for Information Interchange"
			7 binary bits --> 128 unique symbols
			Python now supports Unicode (16-32 bits)
PRINTING WITHOUT NEWLINE?!?!
	for i in range(5):
		print(i, end="") <-- By default, end = "\n", so by setting it so:
	# 0 1 2 3 4
String Formatting: % operator
	Allows us to easily construct a string with placeholders.
	Syntax:
		string_expr % (tuple,of,substs)
	Semantics:
		simplify lefthand string
		left to right, match first placeholder with first substitution value
		substitutions obey special formatting directives
		%d ==> signed integer decimal
		%f ==> floating point, decimal format
		%g ==> floating point, or scientific notation
		%s ==> string(converts things as needed)
		%  ==> no args converted, just a %.
		Implicit conversions:
			Implcit calls to conversion functions occur:
			%s ==> str()
			%d ==> int() # Only on numbers
			%f ==> float() # Same
			Ex:
				"%d %f %s" %(2.5, 3, 5) ==> "2, 3.00000 5"
		Other options:
			"%.2f" %(2/3) --> "0.67" [.2 states the number of columns after decimal]
			"%5dtest"%30 --> "     30test" [enforce min. number of column for entire replacement.
			"%+f" %(5) ==> "+5.00000" [Enforce a leading sign +/-]
			"%(this)s and %(that)d" % ({"this":"me", "that":5}) [Name the inputs]

Sting Formatting: format() method
	A powerful option to craft a string is the format method
		--> include {}'s aroudn an argument number as placeholders in a string (omitted #'s assume in-order argument usage))
		--> provide arguments(zero-indexed) to plug in based on their str() representation
			Ex: "{0}/{1} is {2}".format(13,7,13/7)
				== "13/7 is 1.857142857..."
	More options:
		"{:10.2}".format(0.123) --> "      0.12: #Allows for min.width and # of columns after the decimal. {:minWidth.colsAfterDecimal}
		"{:%}".format(0.12) --> "12.000000%" #Show as a percent
		Align left/center/right:
			"{:>6}".format("hi") -->"    hi"
			"{:<6}".format("hi") -->"hi    "
			"{:^6}".format("hi") -->"  hi  "
			"{:.^6}".format("hi") -->"..hi.."
	Examples:
	"{2}. {0}. {1}.".format("baby shoes","never worn","for sale")
		#for sale. baby shoes. never worn.
	"{:.3%}".format(1/8)
		#12.500%
	print("{:<12}\t{:>10}".format("equilateral","yes"))
	print("{:<12}\t{:>10}".format("acute","possibly"))
		#equilateral	     yes
		#acute			possibly
Debugging and Testing:
	Debugging code is a careful analysis of all assumptions about the code to find which assumption is false.
		Like: "I assume I used correct syntax." "I assume I modified the correct variable", "I assume the list exists before I use it"
		print-Statement debugging:
			When a run-time error occurs, we've assumed some value or variable was used correctly. So print out the relevant variable/expressions.
				Pro: Access variables at confusion portion of code
					 Flexible, easy to use
				Cons:Needs to be removed before code is ready to publish
					 Can introduce their own errors
					 Easy to overuse, makes it hard to tell the difference between debugging and actual program actions.
		Tracing:
			Run the code by hand on specific inputs
			Draw a table of each variables and keep updating its next value.
	Testing:
		Unit Testing -- For the smallest parts of code you can manage, write tests that test this piece of code.
			Programmers often large batch batches of unit tests that can be rerun as desired. This is called "regression testing"
		Two testing Styles:
			Black Box Testing -- Given a piece of code, think about what it is supposed to do and create test cases that give specific inputs and look for the expected outputs/behavior (including failure!)
			White box testing -- "code coverage". Looking at the actual structure of your code, think of test cases that should use/'touch' each part of the code, to make sure each part of the code works when used.
--------
Functions:
	Syntax and Semantics--
		Syntax is how a function is written
			Function call looks like this:
				func_name(argument_expressions)
					Ex: range(2,6,1)
						print("take"+str(3)+"steps")
						my_func()
						int("3"+"7")
		Semantics is the meaning of the function
				Python finds the definition of func_name
				Uses values of the zero-or-more arguments (supplied expressions) to give values to the zero-or-more params.
			Runs the body of the function, returning with a return value
	Functions are a group of instructions performing specific tasks.
		Implements a form of abstraction:
			Abstraction is a global view that helps to hide the details.
		And a form of encapsulation:
			Encapsulation keeps independent blocks of code separate,
			allow multiple statements to be viewed as a singular entity
			Some variables only exist inside the function, so one can safely
			reuse names.
	Allows for another way of branching:
		Conditional Branching--
			Branching driven by the resolution of conditional expressions
				Ex: If x==0: do something
					while x< n: do something again
		Unconditional Branching--
			Function Call: Direct branching, not driven by the resolution of conditional expressions.

	Parameter Lists:
		Parameters are just variables: created because we name them in the parameters list and given a value each time the funcion is called.
		Syntax:
			([unique_identifier [,uniquer_identifier]*])
			Ex:
				def max3 (a,b,c)
				def num_seconds (numDays, numHours, numSecs)
				def showMenu ()
				# Note the list of variables after each function def.
	Notes --
		Defining functions doesn't run it. You need to use it (a function call).
			ex: main(). You need to actually run it.
		Function Definition names parameters. Function call supplies values ('arguments') for those parameters.
			Ex:
				def main(a,b,c):
					something
				^ Function definition
				main(a,b,c) <- function call
		Each call supplies new arguments
			like how each loop-iteration uses next val from a sequence: parameter's and loop var's "assignments" are implicit
--------
Return:
	A function's purpose is to perform calculations (and modify memory or pint?) and then return a value.
	We can specify both that we are ready to leave a function and what value to return with by placing a return statement at that point in code. Syntax: return expr
	A return statement can skip the expression, effectively returning the None value. Syntax: return
	if we reach the end of a function definition without hitting a return statement, it returns None.
	It affects control flow, immediately going back to call site with given value. Like break	
--------
Parameters and Arguments
	Parameters can be positional or (optional by giving default values)
	Arguments can be positional, (ommited by relying on defaults) or identified by keyword

Positional Parameters and Arguments:
	Positional Parameters -- List of identifiers in the formal parameter list of the function header
	Positional arguments  -- list of identifiers in the argument list of the function call
	Parameters get their values based on the arguments' ordering in the functional call
		-- First param gets first arg, 2nd param gets 2nd arg
			def something(x,y) : # x, y are positional parameters
			something(1,2) # 1, 2 are positional arguments

Default Parameters:
	Default parameters are parameters that are assigned default values that should be assumed if no argument is supplied.
		Parameters can still get their values based on the order of the arguments, but if no argument is supplied, default is used.
			Must give all parameters values somehow.
				-- def something(x=1, y=2): #x=1, y=2 are default parameters

You can mix default and positional parameters

Keyword Arguments:
	Keyword Arguments are arguments that feed into a specific formal parameter by name.
		With keyword arguments, the parameters get their values based on the keyword mapping of the arguments, allowing selection of parameters to be directly supplied.
			def something(x=5, y=15): # Default params.
			something(y=25) # Keyword argument.
--------
CODING TIP: PRINT OR RETURN ?!??!
	Best practice: return, instead of printing unless the function's sole purpose is printing.
		This lets us choose what to print at calling site, instead of only being able to print.
--------
Polymorphic Formal Parameters:
	Polymorphic Formal Parameters: Allows varied number of arguments, all packed into a list of the given parameter name.
		Uses the * to designate formal parameter as a working list.
			Syntax: (*list_name)
			ex:
				def something(*x): # Polymorphic param
				# Therefore, these are all okay:
				something(1)
				something(1,2)
				something(1,2,3)
				something() # Given that the function has a use for n
--------
Scope:
	Separate areas of code have differing levels of visibility
		Module file has a scope level (top-level or global scope)
		Each function has its own scope level (sub-level or local scopes)
			Sub-levels (indented bodies of code) of scope can see higher levels of scope but not vice-versa
	The most local version of some identifier is always used when the same name was chosen for a global and local identifier.
		Which can be convenient or confusing.
	When we define local variables in a function, these local variables 'die' when we return/leave the function.
Global keyword references access to a global variable.
--------
Globals:
	A global variable is a variable defined at the "top level", meaning no identation in the file.
	Functions can rely on (or even create) a global by including the global varName statement (as in previous slide)
	They are bad because details that only matter inside a function have bled out into larger scopes. Names can clash, order of definition in files start to matter, and abstraction/encapsulation is not used well.

	Scope:
		Bottom Line: Use sparingly. Mostly disallowed. Better strategy is to use arguments and formal params to pass messages (values) back and forth between the various parts of the program.
		If used: convention is to treat them as global constants, and make them all capital letters.
			global MORTGAGE or global PI
--------
Mutability and Function Calls
	The only thing that ever gets sent from call to function definition is a value (never a variable, expression, etc.), a reference to a list is a value and might be passed.
	Mutability is then the same as always. Aliases might exist, and might modify the same spot in memory where others point.
--------
Meaning of Stars:
	Single Star: multiple arguments are accepted, packed into a tuple and given the supplied name
	Double Star: collect all supplied keyword arguments into a dictionary of this supplied parameter name.
		Keys: Keyword id. Values: supplied values.

Call-Site Stars
	We can also use stars at call sites
		When a function requires multiple arguments, we can unpack a sequence of arguments from a sequence with one star.
			xs = [1,2,3,4,5]
			fiveargs(*xs)
		When a function requires multiple keyword arguments, we can create a dictionary with all of them and then unpack it using two stars.
			d= {a=1, b= 2, c=3}
			func_abc(**d)
--------
Sets
	Are a group of values, no duplicates
	Values are hashable (basically immutable)
		Literals and tuples: Okay, can be in sets
		Lists, dictionaries, other sets not includable
	* Technical difference between hashable and immutable:
		Hashable is a data value that can be 'hashed' into a value.
		Immutable just means they can't change.
		If no one implemented a way to hash an immutable tree, for instance, it'd be immutable but not hashable
	Set Operations:
		Python provides many set operations that should be familiar from math
		Look at the Docs to view.
			A course goal is being comfortable finding, reading, and using docs.
		Set Operations:
			There are two types of sets. Sets and Frozensets, difference is mutability.
			set([iteratble])
				len(s) | length of set
				x in s | if x is in set
				x not in s | if x is not in set
				s.isdisjoint(o) | if set s is disjoint from set o
				s.issubset(o) | if s is a subset of o
				s <= o	| test whether every element in the set is in other
				s < o	| test whether s is a proper subset of o.
				s.issuperset(o) | test whether set is superset of o
				s >= o	| test whether every element of o is in s
				s > o 	| test whether o is a proper subset of s
				s.union(o) | s union o
				s | o	| Return a new set with elements from the set and all others
				s.intersection(o) | s intersect o
				s & o	| return a new set with elements common to the set and all others
				s.difference(o) | get the difference between s and o
				s - o	| return a new set of elements in the set that are not in the others
				s.symmetric_difference(o) | s xor o
				s ^ o	| return a new set with elements in either the set or other but not both
				s.copy() | return a new set with a shallow copy of s.
				s.update(o), or s |= o	| Update the set, adding elements from all others
				s.intersection_update(o) or s &= o	| update the set, keeping only elements found in it and all other.
				s.difference_update(o) or s -= o	| update the set, removing elements found in others
				s.symmetric_difference_update(o) or s ^= o | update the set, keeping only elements found in either set, but not both.
				s.add(x) | add x to set s
				s.remove(x) | remove x from s.
				s.discard(x) | if x is in s, remove it.
				s.pop()	| remove and return an arbitrary element from the set.
				s.clear() | remove all elements.
--------
Dictionary:
	Complex data type (it is compromised of sub-components or elements)
	An unordered group of key-value pairs. This is called a mapping type
	Mutable (key-value pairs updateable)
	creation: common-separated key-value pairs in braces
	syntax:
		{key1:val1, key2:val2} etc.
		dict(key1=val2, key2=val2) etc.
		Curly braces are used as delimiters for the data strcture
		Key and values are associated using a colon and separated from other pairs using a comma
		Keys are hashable (basically, immutable: primatives, strings, tuples...)
		Duplicate keys: later one 'overwrites' ("nearly arbitrary")
		Empty dictionary : {}
	Indexing:
		By key: d[key]
			d = {1:"a", "second":2, None:5}
			d[1] == "a" ; d["second"] == 2 ; d[None] == 5 ; d["atlantis"] => KeyError
		by get() : d.get(key [, else])
			d.get(1) == "a" ; d.get(2) == None ; d.get(1, "uh-oh") == "a" ; d.get(2, "uh-oh") == "uh-oh"
				Notes:
					Returns the key's value or default value when key isn't found.
					The default value for the default is None.
	Operators:
		len(d) | length
		d[key] | indexing
		d.get(k, default) | indexing with get()
		del d[key] | remove key-value pair
		k in d, k not in d | membership testing
		d.clear()	| remove all keyval pairs
		d.copy()	| create shallow copy
		iter(d)		| iterate keys
		d.keys(), d.values(), d.items() | get keys, value, or key-val pairs
		d.pop(k,default) 	| Pop value k or return default
		d.popitem()	| pop any value
		d.update(o)	| insert o into d
	Ex:
		Indexing:
			d = {1:"one", "two";"II", 3.3:30, None:"better"}
			d[1] # == 'one' ; indexing. Give key, get value.
		Reassignment/Assignment:
			d[4] = "for" # <-- assigns key 4 to value "for"
			d[1] = "uno!" # <-- reassigns key 1 to value "uno!"
		Update method:
			d = {1:"uno!", None:"better", 3.3:30, 4:"for", "two";"II"}
			d2 = {5:5}
			d2 = {5:5, 6:6}
			d.update(d2) # Update method. Insert d2 into d
			d == {1:"uno!", 3.3:30, 4:"for", 5:5, 6:6, None:"better", "two":"II"} 
	If item not in dictionary:
		d = {1:"one", "two":"II", 3.3:30}
		d[2] # == Returns a traceback as a KeyError
		d.get(2) # Returns the default. Nothing.
		d.get(2, 0) # Returns the default, 0.
		d.get(2,"oops") # Returns the default, "oops"
	Getting Keys, Value, or Key-Val Pairs:
		d = {"a": 1, "b":2, "c":3}
		d.keys() == dict_keys(['a', 'c', 'b'])
		d.values() == dict_values([1,3,2])
		d.items() == dict_Items([('a',1),('c',3),('b',2)])
	Iteration through dictionary:
		for k in d: # Through the dictionary
			print(k, d[k])
		for k in d.keys(): # Using keys.
			print(k, d[k])
		for v in d.values(): # Using values. Only gets values.
			print(v)
		for (k,v) in d.items() # Gets both keys and values.
			print(k,v)
	Removing Dictionary Elements:
		del d["a"] == dict("b"=2, "c"=3)
		d.pop("b") == dict("c"=3)
			returns 2
		d.pop("b") --> returns keyError
		d.pop('b",'oops') -- > returns default
		del d['garbage'] --> returns keyerror
		d.popitem() # anything left. dict is empty.
			returns ('c',3)
--------
Modules:
	A component providing python definition of functions, variables, or classes.
		Any .py file can be a module.
	Typically consists of a single source code file.
	It's a named thing with lots of more named things.
	We import modules to access things in it.

Importing Modules:
	style of import		  | available	   | Not available
import math					math.pi			pi
							math			sqrt
							math.sqrt		cos
							math.anything	anything
from math import *			pi				math.pi
							sqrt			math.sqrt
							cos				math.cos
							anything		math.anything
from math import (pi, sqrt) pi				math
							sqrt			math.pi
											math.sqrt
											everything else
Other variations

import modName			  | access to all things in modName. Ex: modName.thing
from modName import thing |access to thing
from modName import (thing1,thing2,thing3) | access to thing1,thing2,thing3
from modName import *					   |allows access to all things in modname
--------
File I/O
	Data can be read from and written to a file.
	Three basic steps in code:
		1. Create a file reference and open file
		2. Designate input/output mode
			Accessing or modifying file contents using function.
		3. Close file
	open() Built-In function
		mechanism for establishing an I/O stream
		file_ref is the ref used to call the various methods for I/O methods
			on a file data.
		file_name may be any string expression
		mode denotes the characteristics of I/O stream (read, write, append)
		lookslike: file_ref = open(file_name, mode)
	Three basic modes of access:
		"r" - read from file:
			if file doesn't exist --> error
		"w" - write to file:
			if file exists --> content overwritten
			if file doesn't exist --> file created
		"a" - append file:
			if file exists --> new data appended
			if file doesn't exist --> file created
	Three mixed modes:
		"r+" - read from and write to file
			if file doesn't exist --> error
		"w+" - write to read and from file
			if file exists --> content overwritten
			if file doesn't exist --> file created
		"a+" - append and read from file
			if file exists --> new data appended
			if file doesn't exist --> file created
	Universal Newline support
		Different systems use different characters to representing a newline.
		In order to read a file without these differences mattering (\n,\r\n, all
		the same), we just add a "U" when reading the file.
			"rU" - reads the file, atuomatically converting all versions of
				newlines to \n.
					python's write-mode is always \n
--------
Reading:
	File object methods
		read() - returns entire file as a string
		read(x)- returns next x characters from file
		readline() - returns entire line as string (line position remembered)
		readline(x) - returns next x characters from current line (file and line
			position remembered)
		readlines() - reads/returns all file's lines in a list (newlines present)
--------
Navigating:
	An advanced action is to navigate through a file and read/overwrite specific
		parts
	tell and seek methods:
		tell method - returns current file pointer position
		seek method - moves file pointer to specified positions
		These return position from the end of file
--------
Writing:
	File object methods:
		write(x) writes string x to textfile
		writelines(xs) writes strings in list xs to test file.
-------
Exceptions:
	looks like:
		try:
			<expr> # called a try_suite
		except <exceptiontype> as <reason>: 
			<expr1> # called an except_suite
	Actions taken outside of the normal flow of control because of errors
		1. Exceptional condition occurs
		2. System raises the exceptions
			- Other names for it, triggering, throwing, generating...
		3. programmer handles the exception
			- ignore it, log & ignore, perform corrective ctions
			- otherwise, crash
	try-except:
		if try-suite successful, skip the except
		if any exceptions arise while executing the try-suite, jump directly to
			the except-suite to respond to it and safely continue
		program will no longer crash on bad inputs
		want to try again? Use a loop
	Terms:
		throw an exception: to generate a new exception, which begins crashing its
			way out of the stack of called functions. ('raise' the exception)
		propagate: an exception continues beyond some code block, escaping.
		(continue crashing.)
		catch: to stop an exception from propagating run an except block instead
			("handle" the exception)
	Common Exceptions:
		IOError : I/O operation fails, e.g. trying to open a non-existent file.
		IndexError: tried to index into a sequence with a non-existant index
		KeyError : tried to access a non-existent key in a dictionary
		NameError: identifier for a name couldn't be found in scope
		SyntaxError: syntax error encountered
		TypeError: type error encountered, e.g. argument to built-in is wrong.
		ValueError: built-in func/operation received value of right type but
			wrong value (e.g., got a str, but it doesn't contain a 'number')
		ZeroDivionsError : tried to divide by zero.
	Hierarchy (abbv):
		BaseException
			+-- Keyboard Interrupt
			+-- Exception
			|	+-- ArithmeticError	
			+-- EnvironmentError
			|	+-- IOError
			+-- EOFError
			+-- LookupError
			|	+-- IndexError
			|	+-- KeyError
			+-- NameError
			+-- SyntaxError
			+-- SystemError
			+-- TypeError
			+-- ValueError
	To catch/inspect all exceptions:
		Exception is the ancestor class above all that we use.
		Receive an object of type Exception, and call it e
			This is like a function param
		Looks like:
		try:
			<expr>
		except Exception as e:
			<expr1>
	Validating input:
		Loops continue to execute, raising, and handling exception until user
		complies
	Catching specific types of Exceptions:
		We can catch only certain kinds of error and allow others to propagate (continue crashing)
		Looks like:
			except NameError:
	Catching Multiple Exceptions:
		except (NameError,TypeError,ValueError)
			Other errors still propagate.
		Multiple except-blocks are allowed on a single try-block
			The first except-block that can handle the exception is the only one
				that is run.
			just like elif block
			inheritance is why multiple blocks might be able to handle one 
				except block
			We can still have a catch-all except-block like an else-block
		Finer-grained control by handling each type of exception separately.
			Only first applicable except is run.
			try:
			except NameError:
			except TypeError:
			except KeyError:
			
	Try-except-else
		the else block only runs if no except block ran (and the try-block was
			successful)
	Try-except-else-finally
		Finally block -always- runs:
			after successful try-else-blocks
			after except-block
			before uncaught exception keeps crashing.
	Exception Handling:
		3 basic choices when handling exceptions:
			handle it
			defer it up the calling chain
				exception raised in buggy crashes (propagates) out to whatever called it, which is catching the exception.
				an example: a function takes an int to divide 5 with. if an int
					is not produced, ValueError is produced and returns 0 instead.
					However, if a try-block is put around the function call and 
					the integer given is 0, then a ZeroDevisionError is called instead.
				re-raising exceptions:
					an except-block may raise another exception.
					Lets us react to the exception and still allow propagation.
				Re-raising the same exception:
					we can directly re-raise the caught exception.
					looks like: raise e
			handle it and then defer it up the calling chain
	Raising Exceptions:
		We can generate an exception on purpose (and catch it somewhere else!)
		With a raise statement, which needs an expression of some Exception type (calling __init__).
		Looks like raise Exception("boo!") or raise ArithmeticError ("this doesn't add up!")
		
		Reusing a few specific ExceptionTypes is useful:
			Exception for general issues (but vague)
			ValueError when your code only should be run on some batch of values and the wrong one was given
			Any of them can be reused if it suits your purpose, just call their constractor
			Then you can also make brand new types of exceptions.
		Making an Exception class (sneakpeak):
			we can create our own types of exceptions:
			They can be raised, propagated, and caught just like other exceptions.
				class Disallowed(Exception):
					def __init__(self, value):
						self.value = value
				try:
					x = int(input"#? "))
					if x == 13:
						raise Disallowed("that's unlucky!")
					print(x*10)
				except Disallowed as dis:
					print("uhoh:"+dis.value)
				except Exception as e:
					print(e)
			# That's how you could use a user-defined class for Exceptions.
			# There can be exceptions within classes too
				class LongNameException(Exception):
					def __init__(self, text="too long!"):
						self.text = text
				class Artist(object):
					def __init__(self, name="None"):
						self.__name = name
					def set_name(self,name):
						try:
							if (len(name))>10:
								raise LongNameException()
							else:
								self.__name = name
						except LongNameException as e:
							print(e.text)
			# You can also use instance variables in exceptions.
				class LongNameException(Exception):
					def __init__(self, text="too long!", data=""):
						self.text = text
						self.data = data
				class Artist:
					def __init__(self, name="None"):
						self.__name= name
					def set_name(self,name):
						try:
							if (len(name))>10:
								raise LongNameException(data=(len(name)))
							else:
								self.__name = name
						except LongNameException as e:
							print(e.text+" ("+str(e.data)+")")
--------
Recrusion!!!
	Is something defined in terms of itself.
	Function recursion is when a function calls itself
		Ex:
			def even(n):
				if n == 0: return True
				elif n == 1: return False
				else:
					equivalent = not(even(n-1))
					return equivalent

	Indirect recursion is when a call to some function causes another call to the 		same function by some intermediary
	or otherwise: a function call indirectly caused to call itself again
		Ex:
			funA calls funB
			funB calls funA again (in a different call)
			that funA returns to funB
			funB returns the original call to funA
		ex:
			def even(n): # Notice how one will call the other.
				if n==0:
					return True
				return odd(n-1)
			def odd(n):
				if n==0:
					return False
				return even(n-1)
	To make recursion: make task into base case and recursive case
		base case: the answer is directly calculated with no recursion. param val
		is sufficient
		recursive case: answer calculated y recursively calling function again on
		smaller problem (closer to base case)
	Recipe:
		1. Identify the base case
			"Calculate without the need for recursive call"
		2. Identify the recursive cases, defining the solution in terms of other
		function calls
			"The recursive step, is it using the method on a 'smaller' problem?"
				Hint: Yes.
		3. Write base case code first (allowing to escape recursion)
		4. Write code for recursive cases after base case (Only use recursion
		when base cases aren't sufficient yet)
			+ Extra: Handle errors. Choose exit and returns.
	Separate Calls:
		Each recursive call is distinct:
			Separate frame on the execution stack
			Separate local variables
				Like separate functions with the same implementation.
		Ex: Factorial:
			Math definition --> if n <= 1, fact(n) = 1. #Base
								else: n*fact(n-1) 		# Recursive
			def fact(n):
				if n<= 1:
					return 1
				else:
					return n*fact(n-1)
			So run fact(3)-->
				fact(3) recurses, calling fact(2)
				fact(2) recurses, calling fact(1)
				fact(1) is a base case. returns 1 to fact(2)
				fact(2) gets 1, returns 2 * 1 == 2
				fact(3) gets 2, returning 3*2 == 6.
				fact(3) == 6
	To understand:
		This is based on mathematical indiction.
		If you know p(0), and you know that p(k) implies (->) p(k+1),
			then you can find any p(n) for n >= 0
		Looks like:
			 p(0) == given, base case
		p(0)->p(1)==via induction
		p(1)->p(2)==via induction
		...			...
		p(n-1)->p(n) == via induction	
	Calculation by Recursion:
		Ex, Fibonnaci:
			Math def. fib(n) = 1 				 if n=0 or n =1
							 = fib(n-1)+fib(n-2) otherwise
		def fib(n):						n | fib(n)
			if n<= 1:					0 | 1
				return 1				1 | 1
			return fib(n-1)+fib(n-2)	2 | 1+1 =2
		So the table looks like this>>	3 | 1+2 =3
										4 | 2+3 =5
	And so on.
	Pros and Cons of Recursion:
		Recursion is sometimes much slower, but not always.
		Pro:
			Each call has its own local scope
			Looks like a math definition
			Easy to handle irregular shapes
		Cons:
			Uses more stack space (limits recursion depth)
			Performing function call takes a bit more time than starting next loop				iteration
		Should be used if the solution is straightforward and easy to verify.
			If it runs fast enough, congrats. You're done.
			If you test realistically large inputs and no stack overflows.
			If the number of recursive calls isn't expected to be excessive.
				Given a list of n elements:
					either need <n recursive calls or n known to be small always
				fact(n) has n recursive calls:
					only acceptable on smallish values.
				fib(n) has more than n recursive calls:
					Horrible.
				gcd(n) had less than a or b calls:
					If easy to write, okay to use recursion.
--------
Object Oriented Programming
	Concepts:
		Classes, Objects
		Messages
		Encapsulation/Information Hiding, Abstraction
		Inheritance vs Aggregation
		Polymorphism
	OOP Approach:
		Model a system piece by piece; watch the pieces interact
			Represent each thing as an object
			Each object has its own attributes (data) and behaviors (methods)
		Programmer can write class definitions (blueprints for object values)
		Each object is an instance of a class:
			Specific values for attributes
			All of the class's behaviors available
	Objects communicate/interact with each other via messages
	Grouping all things related to an object inside gives us encapsulation
	Hiding details of objects' behavior implementation provides abstraction
	Classes can be defined in terms of other classes:
		Student is a subgroup of Person
		Truck is subgroup of vehicle
	Specialized versions provide more data, more behaviors, or update behaviors
	Defines a "parent class - child class" relationship.
		Child inherits all the definitions from parent
	Object of child class may always be used when an object of the parent class is
	needed
P	Furniture			A rocking chair object can always be used if we just need
	|					a chair.
C1	-- Table			A stool can be used whenever furniture is needed
	|
	-- Seating			But a table can't be used where a rocking chair is needed.
		|
C2		-- Stool		Trying to model a system by defining what objects exist
		|				and their behaviors.
		-- Chair		A program is making the right objects and watching them
			|			interact or create other objects.
C3			-- Rocking Chair
	Making our own Types:
		We can move beyond the simple data types of our language:
			int, float, str, list, tuple, etc
		Each type can be thought of as a set of values:
			bool = {True, False}
			int  = {..., -2, -1, 0, 1, 2, ...}
		We create our own new types with a class definition: a 'blueprint' of what
		of what is present for a value of this type:
			what pieces of data (variables inside)
			what behaviors (methods)
	Using these Types: Making Objects
		A class defines a new type
		object are the actual values of this type
		An object instantiates the class definition by supplying values for each
		piece of data the class declared it to have.
	Understanding Objects as Values
		Each object is an instance of its class type
			5 is an instance of int. So is 6. They behave differently.
			xs = [1,2,3] and ys = [4,5] are both lists, but contain different data
			The same methods are available on each list, but they might respond
			differently based on their data.
			Two Person objects are both instances of the Person class. They may
			have different names, ages, etc., but can exhibit the same behaviors.
	Object Components
		An object comprises a number of two different kinds of sub-components
			Attributes - Characteristics of the object
			Behaviors - Actions of the object
	What are Objects?
		Generally represent:
			Tangible entites (e.g., student, airline ticket, etc.)
			Intangible entities (e.g., data stream)
		Have associated attributes/behaviors
			Attribute values define the state of the object
			Behaviors define how an object reacts/behaves
		Interaction between objects define system operation
			via message passing - calling each other's methods
		Objects are instances of a particular class
			A class is a blueprint or template for a set of values
	Messages
		Process by which objects interact:
			send data to another object
			request data from another object
			request object to perform some behavior
		Implemented as methods (never called functions...)
			Methods are contained by an object, can operate on the object's data
			Functions are processes that are object independent, can only operate
			on parameters
			(Methods are dependent on object. Functions are dependent on params.)
			(Methods are -in- the object. Functions can do things to objects.)
		Provides basis for OO system operation
	Encapsulation
		means using barriers or boundaries to keep unrelated things apart from
		each other.
		Attributes and behaviors are enclosed (encapsulated) within the logical
		boundary of the object entity
			In structured or procedural systems, data and code are typically
			maintained as separate entities (e.g., functions and variables)
			In OO systems, each object contains data (attributes) and the code
			(behaviors) that operate upon those attributes
	Abstraction
		Encapsulation implements the concept of abstraction
			Details associated with object sub-components are enclosed within the
			boundary of the object
			User of object only 'sees' the abstract perspective offered by the
			object
		Note - In Python, encapsulation is merely a programming convention. Other
		languages enforce it more rigorously.
	Information Hiding:
		Objects <-- Seen by user through Public Interface defined by object
			Behaviors and Attributes are inside of objects
		The Public Interface uses Encapsulation and Modification
		Which leads to Abstraction and Information Hiding
	Class - Object Blueprint
		Serves as a blueprint from which the system can instatiate (create) an 
		object
		Generally consists of:
			Imports, attributes, Constructors, behaviors (methods)
--------
Inheritance
	Generalization - Specialization heirarchy
	Promotes code reuse by allowing more specific sub-classes to be derived from
	more generic super-classes
		Defines child class and parent class relations
	Child inherits attributes/behaviors of parent
		May add additional attributes/behaviors
		Thus making the child more specific
	Every object of child class is still a value of the parent class type
		A Student is a Person. A Cat is an Animal
		every int can be represented as a float, but not vice versa

Base Class		General Class 	Classes that define objects in a generic fashion
Super Class			  |			(i.e., contain attributes and behaviors that are
Parent				  |			common to all descendents)
Ancestor			  |
					  |
					(...)		Classes that consititute objects in a partially
					  |			specific fashion (i.e., contain attributes and
					  |			behaviors that are exclusive to a branch of 
					  |			descendants)
					  |
Derived Class	Specific Class	Classes that define objects in a specific fashion 
Sub Class						(i.e., contain attributes and behaviors that are
Child							exclusive to a particular descendant)
Descendent

Generalization - Specialization Hierarchy (Spectrum)

Inheritance - example
Contains generic attributes (e.g., VIN, color		Vehicle		Maybe abstract
year, etc.) and generic behaviors (accelerate, 		 /\			(uninstantiable)
break, etc.)									    /  \
												   /    \
Contains more specialized attributes (e.g.,		Car  	Truck
4-whell drive, towing hitch, etc.) and more				  /\
specialized behavior (engage 4-wheel drive, etc.)		 /  \
														/	 \
Contains very specialized attributes (e.g.,			Pickup   SUV
pickup: bedcanopy, SUV: rear seat DVD player, etc.)
and more specialized behaviors (pickup: operate
winch, SUV: fold down reare seat, etc.)

Aggregation
	Aggregation is the collecting of other (possibly complex) values. An object
	can have other objects as data, just like a list can have other lists as items
	inside of it.
		Objects may declare and instantiate other object as attributes.
		These other objects are Aggregate objects
	Do not confuse Inheritance relationship with aggregate relationships:
		Ex:
		
		 Monitor	(each aggregate unit can contain other aggregate units)
Desktop <			Mother Board
		Base Unit <
					Disk Drive
					(A desktop Computer can contain aggregate units as attributes)
Inheritance vs. Aggregation
	"IS-A": Inheritance embodies the "is-a" relationship. A Student "is a" Person.
	A Truck "is a" Vehicle"
	"HAS-A": Aggregation embodies the "has-a" relationship: A Student "has a" GPA.
	A Car "has a" Wheel.
--------
Object Oriented Programming in Python
	Python Data Types:
		Primitive Data Types:
			Integer, Floating Point, Boolean, None, etc.
		Complex Data Types:
			Sequence: String, Tuple, List
			Mapping : Dictionary
			Class	: User-Created
	Classes in Python
		Class Definition (blueprint)
			Class definition tells Python how the new data type works
		Object Instantiation (creation)
			An object must be instantiated (created) from the class blueprint
			(with attribute values as arguments) before it can be used.
				The constructor method creates the new object
		Object manipulation (use)
			Once object exists, we can read/write its data (variables); and use
			its behaviors (call its methods)
	Class Definition
		A python class definition contains:
			name (identifier) of the class
			name of parent class (often, just object)
			constructor (method named __init__)
				defines, instantiates the data (attributes)
			methods (behaviors)
	Example: THe Point Class
		A Point is an (x,y) coordinate pair.
			Data: The actual x,y values.
			Methods: shift, etc.
		We define a Point class once, so that we can make lots of Point objects.
	Point class:

class Point(object):
	#Constructor, how to make a Point.)
	def __init__(self, xparam, yparam):
		#creates an x and y for the object
		self.x = xparam
		self.y = yparam
# The __init__ method tells us how to create a Point.
# all methods, not just constructor methods, have self as a first param, so they
# can access the particular object's data.
	
	Defining Attributes
		self.x is an assignment that creates the attribute data named x
			or reassigns if we see a self.x reassigned later on
		all data ought to be added in the constructor.
		every single Point object we make has its own x and its own y.
	Constructor Methods
		Constructor method is named __init__
			Note: Double underscore on both sides (__init__)
			primary duty: assigns values to the object's attributes
		Must have at least one formal parameter(self)
			May have as many as needed/desired
			Constructors may have default parameters
		Calling a constructor (via the class name) tells Python to
			instantiate (create) a new object of the class data type
				ex: Point(1,2)
			Set the object's initial state (run constructor's code)
				ex: self.x becomes 1, self.y becomes 2
			Return a reference to the new object to the caller
	Attributes/Instance Variables
		Attributes represent the characteristics of a class. When an object is
		instantiated and values assigned to the object's attributes, these are
		referred to as instance variables
			They are referred to as instance variables because the object is one
			"instance" of the class, and the values assigned to its attributes are
			unique to that particular object.
		The values of the instance variables define the state of the individual
		object.
			Attributes may be public or private (although due to their specific 
			implementation, they are not truly private in Python)
			If the attributes are private, they serve to enforce the concept of
			information hiding.
	Point Objects
		Create an object - an instance of the class - by calling the constructor
p1 = Point(1,2) # call constructor
p2 = Point(3,4) #call constructor
print("point 1: ", p1.x, p1.y)
print("point 2: ", p2.x, p2.y)
print(p1)
+-------------+
|point 1: 1 2 |
|point 2: 3 4 |
+-------------+ <__main__.Point object at 0x<blah>>
Access attributes with dot-operator.
Syntax: objectexpression.attribute
	Better Printing:
		Provide str() definition
class Point:
	# constructor...
	def __str__(self):
		s = "Point("+str(self.x)+","+str(self.y)+")"
		return s
p1 = Point(1,2)
print(p1) == "Point(1,2)"
# We are overloading the str() functionality
	This is an example of polymorphism: str() works on many types, with
	definitions added in ad-hoc fashion.

	Defining Methods
		A method in our class implements functionality that is only appropriate
		upon an object of the class.
		Always have self as first param
		Each object can use this methods on its personal data (through self).
			update data values
			calculate based on the data
			return a value based on the data
	Adding a method
class Point:
	# constructor, etc.
	def shift(self,xshift=0, yshift=0):
		self.x += xshift
		self.y += yshift
# the method accesses instance variables through self.
# data modified directly - the "side effect" of calling the method is that x and y
# change values.
# no return statement present in our particular shift method, but just like
# functions, we always return something; return statements are normal in methods
# just as in functions.
#		in this case, None is implicitly returned

	Functions vs. Methods
		Functions are modular sets of statements that can be executed to perform
		a task
			Considered stand-alone tasks that generically act upon data submitted
			via arguments and optionally return the processed data to caller.
			E.g., int(data)=>takes data (string) and converts to int
			Data and process are not related.
		Methods are similar but instance of acting generically only upon submitted
		data, they act data associated with specific objects.
			The data and processes are related.

	Scope and Methods
		Method parameters only exist during a particular call of the method.
		Instance variables' values live as long as the object lives (is accessible
		from any part of your code)
		Convention: name parameter and attribute the same.x and self.y are
		different.y and self.y also.

	A need for privacy
		Sometimes data is 'sensitive' - either shouldn't be known outside an
		object or at least shouldn't be directly modifiable by outsiders.
			A bankaccount object's balance shouldn't just be readily modifiable,
			it should only be accessed in controlled fashion: through methods.
	Unsecure Account

class Account:
	def __init__(self, start_bal=0):
		self.bal = start_bal
	def withdraw(self, amount):
		if amount <= self.bal:
			self.bal -= amount
			return amount
		else:
			return 0
	def current_balance(self):
		return bal

	Unsecure Attribute Usage

class Account:
	def __init__(self, start_bal=0):
		self.bal = start_bal
	def withdraw(self, amount):
		self.bal -= amount
		return amount
	def deposit(self, amount):
		self.bal += amount
	def current_balance(self):
		return self.bal

a = Account(50)
print(a.bal) == 50
a.withdraw(-100)
print(a.bal) == 150
a.bal = 99999999
print(a.bal) == 99999999
# The withdraw methods is too trusting. the bal attribute shouldn't be so
# accessible, neither for reading or writing.

	Appropriate to Privacy:
		Private attribute/Methods
		Attributes whose identifiers begin with a double_underscore are private:
		the dot-operator access doesn't work from outside the object.
		Python does allow the programmer to access the private attribute, or
		private method, via the underscore_classname-attribute name.
		Ex:
			A SafeAccount object's __bal can be accessed outside of the object
			with accountExpr._SafeAccount__bal

	Secure (Private) Attribute Usage

class SafeAccount:
	def __init__(self,start_bal=0):
		self.__bal = start_bal
	def withdraw(self, amount):
		if amount>0 and self.__bal >=amount:
			self.__bal -= amount
			return amount
		return 0
	def deposit(self, amount):
		self.__bal += max(0, amount)
	def current_balance(self):
		return self.__bal

	Secure Attribute Usage

a = SafeAccount(50)
print(a.current_balance()) == 50
a.withdraw(-100)
print(a.current_balance()) == 50
a.deposit(-100)
print(a.current_balance()) == 50
# Errors. a.bal = 99999999 ; a.__bal = 999999999
# allowed:
print(a._SafeAccount__bal) == 50
# Python still creates the underscore-classname-attribute as an attribute so it's
# not truly private. This is Python's "we're all adults" approach.
# Makes it harder, but not impossible, to access.

Recipe:
	Using OO in Python
	Choose your data representations when starting up a new project. Some of these
	choices may mean you create new classes.
	Add attributes and behaviors to the class definitions, so that they are useful
	for your particular project.
	Create objects of this class while implementing your project instead of just
	using lists, tuples, etc.
	???
	Profit!
